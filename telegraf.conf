
[[outputs.influxdb_v2]]
urls = ["http://localhost:8086"]
#   ## Token for authentication.
token = "qKoiO86sK0H988D_BkJ1l1cSCdnhJqCd-ehiwk_PkvLgKlJ25rEsUtRLn6qX1_dIu9NAUzJo4ouG1skyYLYdig=="
#
#   ## Organization is the name of the organization you wish to write to; must exist.
organization = "SurinAgro"
#
#   ## Destination bucket to write into.
bucket = "sensors/autogen"


# # Read metrics from MQTT topic(s)
[[inputs.mqtt_consumer]]

#servers = ["ssl://fd0c80775a7d45a5950ae1e6976e7aa5.s1.eu.hivemq.cloud:8883"]
    servers = ["tcp://127.0.0.1:1883"]
    username = "noise83"
    password = "neuro83"
    
    topics = ["esp32_C05070/state/#",
              "esp32_A8CE00/state/#"]
    data_format = "value"
    data_type = "boolean"
    # [[inputs.mqtt_consumer.topic_parsing]]
    #     topic = "+/+/sensors/#"
    #     measurement = "measurement/_/_/_"
    #     tags = "_/_/tag/_"
    #     fields="_/_/_/field"

    [[inputs.mqtt_consumer.topic_parsing]]
        topic = "+/+/outputs/#"
        measurement = "measurement/_/_/_"
        tags = "_/_/tag/_"
        fields="_/_/_/val"
 
[[inputs.modbus]]
    controller = "file:///dev/ttyUSB0"
    baud_rate = 9600
    data_bits = 8
    parity = "N"
    stop_bits = 1
    configuration_type = "request"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 3
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature1",   type="INT16",   scale=0.1 },
      { address=2, name="temperature2",   type="INT16",   scale=0.1 },
      { address=3, name="temperature3",   type="INT16",   scale=0.1 },
      { address=4, name="temperature4",   type="INT16",   scale=0.1 },
      { address=5, name="temperature5",   type="INT16",   scale=0.1 },
      { address=6, name="temperature6",   type="INT16",   scale=0.1 },
      { address=7, name="temperature7",   type="INT16",   scale=0.1 },
      { address=8, name="temperature8",   type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
      location = "main room"




    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
    slave_id = 4
    byte_order = "ABCD"
    register = "input"
    fields = [
      { address=1, name="temperature1",   type="INT16",   scale=0.1 },
      { address=2, name="temperature2",   type="INT16",   scale=0.1 },
      { address=3, name="temperature3",   type="INT16",   scale=0.1 },
      { address=4, name="temperature4",   type="INT16",   scale=0.1 },
      { address=5, name="temperature5",   type="INT16",   scale=0.1 },
      { address=6, name="temperature6",   type="INT16",   scale=0.1 },
      { address=7, name="temperature7",   type="INT16",   scale=0.1 },
      { address=8, name="temperature8",   type="INT16",   scale=0.1 },
    ]

    [inputs.modbus.request.tags]
      location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 10
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "1"
       location = "main room"



    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 11
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "2"
       location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 12
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "3"
       location = "main room"
    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 13
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "4"
       location = "main room"
    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 14
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "5"
       location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 15
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "6"
       location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 16
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "7"
       location = "main room"

    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 17
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "8"
       location = "main room"
    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 18
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "9"
       location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 19
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "10"
       location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 20
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "11"
       location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 21
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "12"
       location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 22
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "13"
       location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 23
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "14"
       location = "main room"


    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 24
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "15"
       location = "main room"



    [[inputs.modbus.request]]
    ## Holding example
    ## All of those examples will result in FLOAT64 field outputs
     slave_id = 25
     byte_order = "ABCD"
     register = "input"
     fields = [
      { address=1, name="temperature",   type="INT16",   scale=0.1   },
      { address=2, name="humidity",      type="INT16",   scale=0.1 },
     ]

     [inputs.modbus.request.tags]
       zone = "16"
       location = "main room"



[inputs.modbus.workarounds]
    ## Pause after connect delays the first request by the specified time.
    ## This might be necessary for (slow) devices.
    pause_after_connect = "100ms"

    ## Pause between read requests sent to the device.
    ## This might be necessary for (slow) serial devices.
    pause_between_requests = "100ms"

    ## Close the connection after every gather cycle.
    ## Usually the plugin closes the connection after a certain idle-timeout,
    ## however, if you query a device with limited simultaneous connectivity
    ## (e.g. serial devices) from multiple instances you might want to only
    ## stay connected during gather and disconnect afterwards.
    # close_connection_after_gather = false

    ## Force the plugin to read each field in a separate request.
    ## This might be necessary for devices not conforming to the spec,
    ## see https://github.com/influxdata/telegraf/issues/12071.
    # one_request_per_field = false

    ## Enforce the starting address to be zero for the first request on
    ## coil registers. This is necessary for some devices see
    ## https://github.com/influxdata/telegraf/issues/8905
    # read_coils_starting_at_zero = false